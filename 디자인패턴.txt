--- 디자인패턴 ---

==> SOLID 원칙 : 소프트웨어 작업에서 프로그래머가 소스 코드가 읽기 쉽고 확장하기 쉽게 될 때까지 소프트웨어 소스 코드를 리팩토링하여 코드 냄새를 제거하기 위해 적용할 수 있는 지침
==> 코드냄새 : 프로그래밍 코드에서 더 심오한 문제를 일으킬 가능성이 있는 프로그램 소스 코드의 특징
==> SRP (Single responsibility principle) : 단일 책임 원칙으로, 객체(클래스)는 하나의 책임만 가져아 한다. (Add 클래스는 더하기를 제외한 다른 사칙연산의 기능을 가지지 않는 것을 추구)
==> OCP (Open/closed principle) : 개방 폐쇠 원칙으로, 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다. (Add 클래스의 기능 보완을 하기 위해서는 AddUpgrade 클래스를 새로 만들어 확장하고 기존 Add 클래스의 변경은 자제하는 것을 추구)
==> LSP (Liskov substitution principle) : 리스코프 치환 원칙으로, 프로그램의 객체(클래스)는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
==> ISP (Interface segregation principle) : 인터페이스 분리 원칙으로, 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
==> DIP (Dependency inversion principle) : 의존관계 역전 원칙으로, 추상화에 의존해야지, 구체화에 의존하면 안되며 의존성 주입은 해당 원칙을 따르는 방법 중 하나이다. (요리사와 같은 넓은 의미에 추상클래스를 만들고 구체화하면 나중에 변화가 찾아와도 다른 클래스들은 요리사에 의존하고 있기 때문에 쉽게 수정할 수 있다.)


1. 전략패턴 : 구체화된 클래스가 아닌 추상화된 클래스에 의존하여 전략을 쉽게 바꿀 수 있는 패턴 (DIP원칙 의존)
2. 프록시패턴 : 클래스의 기능을 변경할 때, 해당 클래스를 직접 변경하는 것이아닌 상속 클래스를 생성하여 확장하는 패턴 (OCP원칙 의존)
3. 어댑터패턴 : 외부요소를 기존 시스템에 재사용하고 싶지만 아직 만들어지지 않은 경우이거나 호환되지 않는 경우에 새로운 클래스에 기존 시스템을 적용시켜 사용하는 패턴 (OCP원칙 의존)
4. 싱글톤패턴 : 객체(클래스)의 인스턴스가 오직 1개만 생성되는 패턴 (메모리, 데이터 공유를 위해 사용)
5. 템플릿 메서드패턴 : 변하지 않는 기능은 부모클래스에 만들어두고 자주 변경하며 확장할 기능은 자식클래스에서 만들어 사용하는 패턴 (객체지향적 구조로 중복코드를 줄이고 핵심 로직의 관리가 용이)
6. 데코레이터 패턴 : 주어진 상황 및 용도에 따라 어떤 객체(클래스)에 책임을 덧붙이는 패턴 (기능 확장이 필요할 때 서브클래싱 대신 쓸 수 있는 유연한 대안)
7. 팩토리 패턴 : 객체(클래스) 생성 하는 코드를 분리하여 클라이언트 코드와 결합도(의존성)를 낮추어 코드를 건드리는 횟수를 최소화 하기 위한 패턴 (다형성을 이용하여 인터페이스를 구현한 객체들은 같은 인터페이스를 바라 보기 때문에 코드에 유연함)
8. 옵저버 패턴 : 객체(클래스)의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 패턴
(클라이언트가 서버 상태의 변화가 궁금할 때, 계속 상태를 물어봐야 하는데 이렇게 계속 상태를 물어보는 것을 폴링 방식이라고 하는데 이것을 너무 비효율적이기 때문에 클라이언트의 목록을 등록하고 상태가 변화 되었을 때 서버가 목록에 등록된 클라이언트에 상태변화를 알려주는 것을 푸시방식이라고 한다.)

==> 모든 디자인패턴은 구체화된 클래스가 아닌 추상화된 클래스에 의존하여 객체(클래스)간 의존성을 낮춰 코드 핵심 로직의 관리와 코드변경을 보다 쉽게할 수 있고 중복코드를 감소시켜 공통된 형태(패턴)를 만듬으로써 개인의 업무, 협업에서의 효율을 높이는 것을 목적으로 한다.  
==> 디자인패턴은 지키지 않아도 컴파일 과정에서 오류가 발생하는것이 아닌 좋은 형태를 추천하는 것뿐이다.
